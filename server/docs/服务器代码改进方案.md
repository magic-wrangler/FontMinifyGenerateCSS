# 服务器代码改进方案

## 现状分析

通过对服务器代码的分析，发现以下几个方面的情况：

### 1. 目录结构

- 基本结构清晰，包含主要文件和功能模块
- 缺少明确的模块化分层（如路由、控制器、服务等）

### 2. 代码风格

- 使用了CommonJS模块系统
- 代码有注释，但注释不够系统化
- 错误处理有基本实现，但不够全面

### 3. 日志系统

- 已实现基础日志功能，包括访问日志、错误日志
- 日志记录机制需要优化，特别是响应结果的捕获方式

### 4. API设计

- API路由直接在主文件中定义，缺乏模块化
- 缺少统一的响应格式规范

## 改进方案

### 1. 目录结构优化

建议采用以下目录结构：

```
server/
├── config/             # 配置文件
│   ├── db.js           # 数据库配置
│   ├── logger.js       # 日志配置
│   └── app.js          # 应用配置
├── controllers/        # 控制器
│   ├── fontController.js
│   └── ...
├── middlewares/        # 中间件
│   ├── errorHandler.js # 错误处理中间件
│   ├── validator.js    # 请求验证中间件
│   └── ...
├── models/             # 数据模型（如果有）
│   └── ...
├── routes/             # 路由
│   ├── api.routes.js   # API路由
│   ├── index.js        # 路由聚合
│   └── ...
├── services/           # 业务逻辑
│   ├── fontService.js
│   └── ...
├── utils/              # 工具函数
│   ├── logger.js
│   ├── response.js     # 响应格式化工具
│   └── ...
├── tests/              # 测试文件
│   └── ...
└── index.js            # 应用入口
```

### 2. 代码规范改进

#### 2.1 采用ESM模块系统

- 将 `require()` 替换为 `import/export`
- 更好的支持现代JavaScript特性

示例：

```javascript
// 旧版本
const express = require('express');
const router = express.Router();
module.exports = router;

// 新版本
import express from 'express';
const router = express.Router();
export default router;
```

#### 2.2 统一错误处理

- 创建全局错误处理中间件
- 定义标准错误类和错误码

示例：

```javascript
// utils/errors.js
export class AppError extends Error {
  constructor(message, statusCode, errorCode) {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

// middlewares/errorHandler.js
export const errorHandler = (err, req, res, next) => {
  const statusCode = err.statusCode || 500;
  const errorCode = err.errorCode || 'INTERNAL_ERROR';
  
  res.status(statusCode).json({
    code: statusCode,
    success: false,
    message: err.message || '服务器内部错误',
    errorCode,
    timestamp: Date.now()
  });
  
  // 记录错误日志
  logger.error(`${statusCode} - ${err.message} - ${req.originalUrl} - ${req.method} - ${req.ip}`);
};
```

#### 2.3 API响应格式统一

```javascript
// utils/response.js
export const successResponse = (res, data = {}, message = '操作成功') => {
  return res.status(200).json({
    code: 200,
    success: true,
    data,
    message,
    timestamp: Date.now()
  });
};

export const errorResponse = (res, statusCode = 500, message = '操作失败', errorCode = 'INTERNAL_ERROR') => {
  return res.status(statusCode).json({
    code: statusCode,
    success: false,
    message,
    errorCode,
    timestamp: Date.now()
  });
};
```

### 3. 日志系统优化

#### 3.1 使用专业日志库

- 引入 winston 或 pino 等成熟日志库
- 配置不同级别的日志输出

示例（使用winston）：

```javascript
// config/logger.js
import winston from 'winston';
import path from 'path';

const logDir = path.join(process.cwd(), 'logs');

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    new winston.transports.File({ filename: path.join(logDir, 'error.log'), level: 'error' }),
    new winston.transports.File({ filename: path.join(logDir, 'combined.log') })
  ]
});

export default logger;
```

#### 3.2 优化日志记录中间件

- 将当前的响应拦截和日志记录逻辑分离
- 使用更可靠的方式捕获响应内容

```javascript
// middlewares/requestLogger.js
import logger from '../utils/logger.js';

export const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  // 在响应结束时记录日志
  res.on('finish', () => {
    const duration = Date.now() - start;
    const logMessage = `${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`;
    
    if (res.statusCode >= 400) {
      logger.warn(logMessage);
    } else {
      logger.info(logMessage);
    }
  });
  
  next();
};
```

### 4. 安全性增强

#### 4.1 输入验证

- 引入 express-validator 进行请求验证
- 对所有用户输入进行严格验证

示例：

```javascript
// middlewares/validator.js
import { body, validationResult } from 'express-validator';

export const validateGenerateCSS = [
  body('text').isString().notEmpty().withMessage('文本内容不能为空'),
  body('fontNames').isArray().notEmpty().withMessage('字体名称列表不能为空'),
  body('sessionId').isString().notEmpty().withMessage('会话ID不能为空'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        code: 400,
        success: false,
        message: '请求参数验证失败',
        errors: errors.array(),
        timestamp: Date.now()
      });
    }
    next();
  }
];
```

#### 4.2 限流保护

- 添加 express-rate-limit 防止DoS攻击
- 对敏感API设置更严格的限制

```javascript
// middlewares/rateLimiter.js
import rateLimit from 'express-rate-limit';

export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 每个IP在windowMs内最多可以发送100个请求
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    code: 429,
    success: false,
    message: '请求过于频繁，请稍后再试',
    timestamp: Date.now()
  }
});

// 对文件上传API设置更严格的限制
export const uploadLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1小时
  max: 10, // 每个IP在windowMs内最多可以发送10个请求
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    code: 429,
    success: false,
    message: '上传请求过于频繁，请稍后再试',
    timestamp: Date.now()
  }
});
```

### 5. 性能优化

#### 5.1 缓存机制

- 为频繁访问的资源添加缓存
- 使用内存缓存或Redis缓存热点数据

```javascript
// utils/cache.js
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 600 }); // 默认缓存10分钟

export const getCache = (key) => {
  return cache.get(key);
};

export const setCache = (key, value, ttl = 600) => {
  return cache.set(key, value, ttl);
};

export const deleteCache = (key) => {
  return cache.del(key);
};

export const flushCache = () => {
  return cache.flushAll();
};

// 缓存中间件
export const cacheMiddleware = (req, res, next) => {
  const key = req.originalUrl;
  const cachedResponse = getCache(key);
  
  if (cachedResponse) {
    return res.status(200).json(cachedResponse);
  }
  
  // 保存原始的res.json方法
  const originalJson = res.json;
  
  // 重写res.json方法，在发送响应前缓存结果
  res.json = function(data) {
    if (res.statusCode === 200) {
      setCache(key, data);
    }
    return originalJson.call(this, data);
  };
  
  next();
};
```

#### 5.2 异步处理优化

- 使用 async/await 替代回调
- 对耗时操作使用队列处理

```javascript
// services/queueService.js
import Queue from 'bull';
import logger from '../utils/logger.js';

// 创建字体处理队列
const fontProcessingQueue = new Queue('font-processing', {
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379
  }
});

// 处理队列任务
fontProcessingQueue.process(async (job) => {
  const { fontNames, text, sessionId, outputDir } = job.data;
  
  try {
    // 处理字体文件
    const results = await processFontFiles(fontNames, text, sessionId, outputDir);
    return results;
  } catch (error) {
    logger.error(`Error processing font job: ${error.message}`);
    throw error;
  }
});

// 添加任务到队列
export const addFontProcessingJob = async (data) => {
  const job = await fontProcessingQueue.add(data, {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000
    }
  });
  
  return job.id;
};

// 获取任务状态
export const getFontProcessingJobStatus = async (jobId) => {
  const job = await fontProcessingQueue.getJob(jobId);
  if (!job) {
    return null;
  }
  
  const state = await job.getState();
  const result = job.returnvalue;
  const error = job.failedReason;
  
  return {
    id: job.id,
    state,
    result,
    error
  };
};
```

## 实施建议

建议按以下步骤实施改进：

1. 首先重构目录结构，将现有功能模块化
   - 创建路由、控制器、服务等目录
   - 将相关代码移至对应目录

2. 引入统一的错误处理和响应格式
   - 创建错误处理中间件
   - 实现统一的响应工具函数

3. 优化日志系统，引入专业日志库
   - 安装并配置winston或pino
   - 重构日志记录中间件

4. 增强安全性和性能优化措施
   - 添加请求验证
   - 实现限流保护
   - 添加缓存机制
   - 对耗时操作使用队列处理

5. 添加自动化测试确保功能正常
   - 编写单元测试和集成测试
   - 设置CI/CD流程

这些改进将使代码更加规范、可维护，并提高系统的稳定性和安全性。

## 技术栈建议

### 核心依赖

- **express**: Web框架
- **winston**: 日志库
- **express-validator**: 请求验证
- **express-rate-limit**: 限流保护
- **node-cache** 或 **redis**: 缓存
- **bull**: 任务队列
- **jest**: 测试框架

### 开发依赖

- **eslint**: 代码检查
- **prettier**: 代码格式化
- **nodemon**: 开发热重载
- **dotenv**: 环境变量管理
- **supertest**: API测试

## 迁移策略

为了平稳过渡，建议采用渐进式迁移策略：

1. 保持现有功能正常运行的同时，逐步引入新的结构和模式
2. 先完成基础设施改进（日志、错误处理）
3. 然后重构业务逻辑
4. 最后添加新功能和优化


1.首先重构目录结构，将现有功能模块化 ✅
2. 引入统一的错误处理和响应格式
3. 优化日志系统，引入专业日志库
4. 增强安全性和性能优化措施
5. 添加自动化测试确保功能正常