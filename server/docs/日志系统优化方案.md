# 日志系统优化方案

## 1. 当前日志系统分析

### 1.1 现有实现
目前系统使用自定义的`Logger`类实现日志功能，主要特点：
- 基于文件系统的日志存储
- 按日期和日志类型（错误、访问）分类存储
- 支持错误日志和访问日志记录
- 日志格式为JSON
- 同时输出到控制台和文件

### 1.2 存在的问题
- 缺乏日志级别划分（如debug、info、warn、error等）
- 没有日志轮转机制，可能导致日志文件过大
- 缺少日志过滤和查询能力
- 性能问题：同步写入文件可能影响应用性能
- 缺乏可配置性：日志格式、存储位置等难以灵活配置
- 错误处理机制简单，日志写入失败时只能打印到控制台
- 不支持结构化查询和分析

## 2. 专业日志库选型

### 2.1 推荐使用Winston
推荐使用**Winston**作为Node.js应用的日志库，理由如下：

- **成熟稳定**：Winston是Node.js生态中最流行的日志库之一，社区活跃
- **高度可配置**：支持自定义日志级别、格式和输出目标
- **多种传输方式**：支持控制台、文件、HTTP、数据库等多种输出方式
- **插件生态**：丰富的插件支持（如日志轮转、格式化等）
- **性能优良**：支持异步日志写入，不阻塞主线程
- **支持结构化日志**：便于后期分析和处理

### 2.2 其他备选方案
- **Pino**：性能更优，但功能相对简单
- **Bunyan**：JSON格式日志，适合与ELK等日志分析系统集成
- **log4js**：类似Java的log4j，配置方式熟悉

## 3. 新日志系统设计

### 3.1 架构设计
![日志系统架构](https://placeholder-for-architecture-diagram)

### 3.2 核心功能
- **多级别日志**：debug、info、warn、error、fatal
- **多传输目标**：控制台、文件、可选的远程服务
- **日志轮转**：按大小或时间自动轮转日志文件
- **上下文关联**：支持请求ID关联，便于追踪完整请求流程
- **格式化选项**：支持JSON和可读文本格式
- **性能优化**：异步写入，批量处理
- **可配置性**：通过配置文件灵活调整日志行为

### 3.3 日志分类
- **应用日志**：记录应用运行状态、业务流程等
- **访问日志**：记录HTTP请求和响应
- **错误日志**：记录应用异常和错误
- **性能日志**：记录关键操作的性能指标（可选）

## 4. 实施方案

### 4.1 依赖安装
```bash
npm install winston winston-daily-rotate-file
# 或使用pnpm
pnpm add winston winston-daily-rotate-file
```

### 4.2 日志配置示例
```javascript
// server/config/logger.config.js
module.exports = {
  // 日志级别
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  
  // 日志目录
  directory: 'logs',
  
  // 文件配置
  file: {
    maxSize: '10m',      // 单个文件最大大小
    maxFiles: '14d',     // 保留日志时间
    zippedArchive: true, // 是否压缩归档
  },
  
  // 格式配置
  format: 'json',        // 'json' 或 'text'
  
  // 控制台输出
  console: {
    enabled: true,
    level: 'debug',
  }
};
```

### 4.3 日志实现示例
```javascript
// server/utils/logger.js
const winston = require('winston');
const { createLogger, format, transports } = winston;
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');
const config = require('../config/logger.config');

// 创建日志目录
const logDir = path.join(__dirname, '..', config.directory);

// 定义日志格式
const logFormat = config.format === 'json' 
  ? format.json()
  : format.printf(({ level, message, timestamp, ...meta }) => {
      return `${timestamp} ${level}: ${message} ${Object.keys(meta).length ? JSON.stringify(meta) : ''}`;
    });

// 创建文件传输
const fileTransport = new DailyRotateFile({
  dirname: logDir,
  filename: '%DATE%-app.log',
  datePattern: 'YYYY-MM-DD',
  maxSize: config.file.maxSize,
  maxFiles: config.file.maxFiles,
  zippedArchive: config.file.zippedArchive
});

// 创建错误文件传输
const errorFileTransport = new DailyRotateFile({
  dirname: path.join(logDir, 'errors'),
  filename: '%DATE%-error.log',
  datePattern: 'YYYY-MM-DD',
  maxSize: config.file.maxSize,
  maxFiles: config.file.maxFiles,
  level: 'error',
  zippedArchive: config.file.zippedArchive
});

// 创建访问日志传输
const accessFileTransport = new DailyRotateFile({
  dirname: path.join(logDir, 'access'),
  filename: '%DATE%-access.log',
  datePattern: 'YYYY-MM-DD',
  maxSize: config.file.maxSize,
  maxFiles: config.file.maxFiles,
  zippedArchive: config.file.zippedArchive
});

// 定义传输数组
const logTransports = [fileTransport, errorFileTransport];

// 添加控制台传输（如果启用）
if (config.console.enabled) {
  logTransports.push(new transports.Console({
    level: config.console.level,
    format: format.combine(
      format.colorize(),
      format.simple()
    )
  }));
}

// 创建logger实例
const logger = createLogger({
  level: config.level,
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    logFormat
  ),
  transports: logTransports,
  exitOnError: false
});

// 创建访问日志记录器
const accessLogger = createLogger({
  level: 'info',
  format: format.combine(
    format.timestamp(),
    format.json()
  ),
  transports: [accessFileTransport],
  exitOnError: false
});

// 辅助函数：记录HTTP请求
const logAccess = (req, res, responseTime) => {
  const { method, originalUrl, ip, headers, query, body } = req;
  const userAgent = headers['user-agent'];
  const statusCode = res.statusCode;
  
  accessLogger.info('HTTP Access', {
    method,
    url: originalUrl,
    statusCode,
    responseTime,
    ip,
    userAgent,
    query,
    // 避免记录敏感信息
    body: sanitizeBody(body)
  });
};

// 辅助函数：清理敏感信息
const sanitizeBody = (body) => {
  if (!body) return {};
  
  const sanitized = { ...body };
  // 移除敏感字段
  const sensitiveFields = ['password', 'token', 'secret'];
  sensitiveFields.forEach(field => {
    if (sanitized[field]) sanitized[field] = '[REDACTED]';
  });
  
  return sanitized;
};

module.exports = {
  logger,
  logAccess,
  // 导出常用日志方法
  debug: (...args) => logger.debug(...args),
  info: (...args) => logger.info(...args),
  warn: (...args) => logger.warn(...args),
  error: (...args) => logger.error(...args),
  // 用于中间件
  accessMiddleware: (req, res, next) => {
    const start = Date.now();
    
    // 响应结束时记录访问日志
    res.on('finish', () => {
      const responseTime = Date.now() - start;
      logAccess(req, res, responseTime);
    });
    
    next();
  }
};
```

### 4.4 中间件集成
```javascript
// server/middlewares/requestLogger.js
const { accessMiddleware } = require('../utils/logger');

module.exports = accessMiddleware;
```

### 4.5 错误处理集成
```javascript
// server/middlewares/errorHandler.js
const { logger } = require('../utils/logger');
const { BusinessError, NotFoundError } = require('../utils/errors');

module.exports = (err, req, res, next) => {
  // 记录错误日志
  if (err instanceof BusinessError) {
    logger.warn(`业务错误: ${err.message}`, { 
      code: err.code,
      stack: err.stack,
      url: req.originalUrl
    });
  } else if (err instanceof NotFoundError) {
    logger.info(`资源未找到: ${err.message}`, {
      url: req.originalUrl
    });
  } else {
    logger.error(`服务器错误: ${err.message}`, {
      stack: err.stack,
      url: req.originalUrl,
      method: req.method
    });
  }
  
  // 错误响应处理...
  next(err);
};
```

## 5. 迁移计划

### 5.1 迁移步骤
1. 安装Winston及相关依赖
2. 创建日志配置文件
3. 实现新的logger模块
4. 更新中间件引用新的logger
5. 更新控制器和服务中的日志调用
6. 测试日志功能
7. 移除旧的logger实现

### 5.2 兼容性考虑
为确保平滑迁移，可以考虑以下策略：
- 保持API兼容：新logger可以提供与旧logger相同的方法签名
- 渐进式替换：先在非关键路径使用新logger，验证后再全面替换
- 双写阶段：关键系统可以同时写入新旧日志系统，确保数据不丢失

### 5.3 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| 日志丢失 | 迁移期间保留旧日志系统，确保双写 |
| 性能下降 | 使用异步日志，避免阻塞主线程 |
| 磁盘空间不足 | 实施日志轮转和归档策略 |
| 代码兼容性问题 | 全面测试，特别是错误处理路径 |

## 6. 未来扩展

### 6.1 可能的扩展方向
- **集中式日志管理**：接入ELK或类似日志分析平台
- **告警机制**：基于日志级别和内容触发告警
- **性能监控**：扩展日志系统记录性能指标
- **用户行为分析**：基于访问日志分析用户行为模式

### 6.2 推荐工具链
- **日志收集**：Filebeat、Fluentd
- **日志存储与分析**：Elasticsearch
- **日志可视化**：Kibana、Grafana
- **告警系统**：Prometheus + Alertmanager

## 7. Grafana集成准备

### 7.1 Grafana简介
Grafana是一个开源的指标分析与可视化套件，可以用于展示时序数据、应用监控和日志分析。通过与日志系统集成，可以实现：
- 实时监控应用状态和性能
- 创建自定义仪表盘展示关键指标
- 设置告警规则并通知相关人员
- 分析日志模式和趋势

### 7.2 日志格式适配
为了更好地与Grafana集成，日志格式需要进行以下调整：

```javascript
// 为Grafana优化的日志格式
const grafanaFormat = format.combine(
  format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss.SSS'
  }),
  format.label({ label: 'font-service' }),  // 服务标识
  format.metadata({ fillExcept: ['timestamp', 'level', 'message', 'label'] }),
  format.json()
);
```

### 7.3 指标收集
除了日志外，还应收集以下关键指标以便在Grafana中展示：

1. **应用性能指标**
   - API响应时间
   - 请求吞吐量
   - 错误率
   - 内存使用情况

2. **业务指标**
   - 字体处理数量
   - CSS生成成功率
   - 用户会话数量
   - 文件上传大小分布

### 7.4 Loki集成方案
推荐使用Grafana Loki作为日志聚合系统，它与Grafana无缝集成且资源消耗较低：

```javascript
// 添加Loki传输
const { LokiTransport } = require('winston-loki');

// Loki传输配置
const lokiTransport = new LokiTransport({
  host: 'http://loki:3100',
  labels: { job: 'font-service' },
  json: true,
  format: format.combine(
    format.timestamp(),
    format.json()
  ),
  onConnectionError: (err) => console.error(err)
});

// 将Loki传输添加到logger
logger.add(lokiTransport);
```

### 7.5 部署架构
![Grafana部署架构](https://placeholder-for-grafana-architecture)

推荐的Grafana集成部署架构包括：
- **应用服务器**：运行字体处理服务，使用Winston记录日志
- **Promtail/Filebeat**：收集日志文件并发送到Loki
- **Loki**：存储和索引日志数据
- **Prometheus**：收集和存储应用指标
- **Grafana**：提供统一的可视化界面

### 7.6 实施步骤
1. 安装必要的依赖：`winston-loki`、`prom-client`
2. 配置Winston以适应Grafana/Loki格式
3. 设置Prometheus指标收集
4. 部署Loki和Grafana服务
5. 创建初始仪表盘和告警规则

### 7.7 示例仪表盘
Grafana仪表盘可以包含以下面板：
- 请求量和响应时间趋势图
- 错误率和错误类型分布
- 系统资源使用情况
- 字体处理性能指标
- 日志搜索和过滤界面

## 8. 结论

引入Winston作为专业日志库将显著提升系统的日志管理能力，带来以下好处：
- 提高日志系统的可靠性和性能
- 增强日志的可读性和可分析性
- 降低维护成本
- 为未来的系统监控和分析奠定基础
- 为Grafana等可视化工具的集成做好准备

建议按照本文档的实施方案进行迁移，并根据实际情况调整配置参数。